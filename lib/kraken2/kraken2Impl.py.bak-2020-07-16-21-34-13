# -*- coding: utf-8 -*-
#BEGIN_HEADER
import logging
import os
import sys
import subprocess
import pandas as pd
import re
from pprint import pprint, pformat

from installed_clients.KBaseReportClient import KBaseReport
from installed_clients.ReadsUtilsClient import ReadsUtils
from installed_clients.AssemblyUtilClient import AssemblyUtil
from installed_clients.DataFileUtilClient import DataFileUtil as DFUClient
from installed_clients.WorkspaceClient import Workspace as workspaceService
from installed_clients.SetAPIServiceClient import SetAPI
#END_HEADER


class kraken2:
    '''
    Module Name:
    kraken2

    Module Description:
    A KBase module: kraken2
    '''

    ######## WARNING FOR GEVENT USERS ####### noqa
    # Since asynchronous IO can lead to methods - even the same method -
    # interrupting each other, you must be *very* careful when using global
    # state. A method could easily clobber the state set by another while
    # the latter method is running.
    ######################################### noqa
    VERSION = "0.0.1"
    GIT_URL = "git@github.com:mflynn-lanl/kbase-kraken2.git"
    GIT_COMMIT_HASH = "0a49cd94d4e8c8b533cf6cbad91fbe747886dc47"

    #BEGIN_CLASS_HEADER

    def log(self, target, message):
        if target is not None:
            target.append(message)
        print(message)
        sys.stdout.flush()

    def _generate_report_table(self, report_df, outfile, output_dir):
        pd.set_option('colheader_justify', 'center')  # FOR TABLE <th>
        with open(os.path.join(output_dir, 'df_style.css'), 'w') as fp:
            css_string = '''
            .mystyle {
                font-size: 11pt; 
                font-family: Arial;
                border-collapse: collapse; 
                border: 1px solid silver;
            
            }
            
            .mystyle td, th {
                padding: 5px;
            }
            
            .mystyle tr:nth-child(even) {
                background: #E0E0E0;
            }
            
            .mystyle tr:hover {
                background: silver;
                cursor: pointer;
            }
            '''
            fp.write(css_string)

        html_string = '''
        <html>
          <head>
          <link rel="stylesheet" type="text/css" href="df_style.css"/>
          <title>Kraken2 Report</title></head>
          <body>
            {table}
          </body>
        </html>.
        '''

        # OUTPUT AN HTML FILE
        with open(outfile, 'w') as f:
            f.write(html_string.format(table=report_df.to_html(classes='mystyle', index=False), css=os.path.join(output_dir, 'df_style.css')))

    def package_folder(self, folder_path, zip_file_name, zip_file_description):
        ''' Simple utility for packaging a folder and saving to shock '''
        if folder_path == self.shared_folder:
            raise ValueError ("cannot package scatch itself.  folder path: "+folder_path)
        elif not folder_path.startswith(self.shared_folder):
            raise ValueError ("cannot package folder that is not a subfolder of scratch.  folder path: "+folder_path)
        dfu = DFUClient(self.callback_url)
        if not os.path.exists(folder_path):
            raise ValueError ("cannot package folder that doesn't exist: "+folder_path)
        output = dfu.file_to_shock({'file_path': folder_path,
                                    'make_handle': 0,
                                    'pack': 'zip'})
        return {'shock_id': output['shock_id'],
                'name': zip_file_name,
                'label': zip_file_description}
    #END_CLASS_HEADER

    # config contains contents of config file in a hash or None if it couldn't
    # be found
    def __init__(self, config):
        #BEGIN_CONSTRUCTOR
        self.workspaceURL = config['workspace-url']
        self.shockURL = config['shock-url']
        self.handleURL = config['handle-service-url']
        self.serviceWizardURL = config['service-wizard-url']
        self.callback_url = os.environ['SDK_CALLBACK_URL']
        self.shared_folder = config['scratch']

        if not os.path.exists(self.shared_folder):
            os.makedirs(self.shared_folder)
        os.chdir(self.shared_folder)
        self.dfu = DFUClient(self.callback_url)
        logging.basicConfig(format='%(created)s %(levelname)s: %(message)s',
                            level=logging.INFO)
        #END_CONSTRUCTOR
        pass


    def run_kraken2(self, ctx, params):
        """
        This example function accepts any number of parameters and returns results in a KBaseReport
        :param params: instance of mapping from String to unspecified object
        :returns: instance of type "ReportResults" -> structure: parameter
           "report_name" of String, parameter "report_ref" of String
        """
        # ctx is the context object
        # return variables are: output
        #BEGIN run_kraken2

        # Download input data as FASTA or FASTQ
        logging.info(f'params {params}')
        token = ctx['token']
        wsClient = workspaceService(self.workspaceURL, token=token)
        headers = {'Authorization': 'OAuth ' + token}
        env = os.environ.copy()
        env['KB_AUTH_TOKEN'] = token
        # object info
        [OBJID_I, NAME_I, TYPE_I, SAVE_DATE_I, VERSION_I, SAVED_BY_I, WSID_I, WORKSPACE_I, CHSUM_I, SIZE_I,
         META_I] = range(11)  # object_info tuple

        Set_types = ["KBaseSets.ReadsSet", "KBaseRNASeq.RNASeqSampleSet"]
        PE_types = ["KBaseFile.PairedEndLibrary", "KBaseAssembly.PairedEndLibrary"]
        SE_types = ["KBaseFile.SingleEndLibrary", "KBaseAssembly.SingleEndLibrary"]
        acceptable_types = Set_types + PE_types + SE_types
        # Determine whether read library or read set is input object
        #
        try:
            input_reads_obj_info = \
            wsClient.get_object_info([{'ref': params['input_refs']}], 1)[0]
            logging.info(f'object info {input_reads_obj_info}')
            input_reads_obj_type = input_reads_obj_info[TYPE_I]
            input_reads_obj_type = re.sub('-[0-9]+\.[0-9]+$', "", input_reads_obj_type)  # remove trailing version
        except Exception as e:
            raise ValueError('Unable to get read library object from workspace: (' + str(
                params['input_refs']) + ')' + str(e))

        if input_reads_obj_type not in acceptable_types:
            raise ValueError(
                "Input reads of type: '" + input_reads_obj_type + "'.  Must be one of " + ", ".join(acceptable_types))
        # auto-detect reads type
        read_type = None
        if input_reads_obj_type in PE_types:
            read_type = 'PE'
        elif input_reads_obj_type in SE_types:
            read_type = 'SE'
        logging.info(f'input_reads_obj_type {input_reads_obj_type}, read_type {read_type}')
        # get set
        #
        readsSet_ref_list = []
        readsSet_names_list = []
        if input_reads_obj_type in Set_types:
            try:
                # self.log (console, "INPUT_READS_REF: '"+input_params['input_refs']+"'")  # DEBUG
                # setAPI_Client = SetAPI (url=self.callbackURL, token=ctx['token'])  # for SDK local.  doesn't work for SetAPI
                setAPI_Client = SetAPI(url=self.serviceWizardURL, token=ctx['token'],
                                       service_ver='beta')  # for dynamic service
                input_readsSet_obj = setAPI_Client.get_reads_set_v1(
                    {'ref': params['input_refs'], 'include_item_info': 1})
                logging.info(f'input_readsSet_obj {input_readsSet_obj}')
            except Exception as e:
                raise ValueError('SetAPI FAILURE: Unable to get read library set object from workspace: (' + str(
                    params['input_refs']) + ")\n" + str(e))
            for readsLibrary_obj in input_readsSet_obj['data']['items']:
                readsSet_ref_list.append(readsLibrary_obj['ref'])
                readsSet_names_list.append(readsLibrary_obj['info'][NAME_I])
                reads_item_type = readsLibrary_obj['info'][TYPE_I]
                reads_item_type = re.sub('-[0-9]+\.[0-9]+$', "", reads_item_type)  # remove trailing version
                if reads_item_type in PE_types:
                    this_read_type = 'PE'
                elif reads_item_type in SE_types:
                    this_read_type = 'SE'
                else:
                    raise ValueError("Can't handle read item type '" + reads_item_type + "' obj_name: '" +
                                     readsLibrary_obj['info'][NAME_I] + " in Set: '" + str(
                        params['input_refs']) + "'")
                if read_type is not None and this_read_type != read_type:
                    raise ValueError("Can't handle read Set: '" + str(params[
                                                                          'input_refs']) + "'.  Unable to process mixed PairedEndLibrary and SingleEndLibrary.  Please split into separate ReadSets")
                elif read_type is None:
                    read_type = this_read_type
        else:
            readsSet_ref_list = [params['input_refs']]
            readsSet_names_list = [input_reads_obj_info[NAME_I]]

        # Iterate through readsLibrary members of set
        #
        report = ''

        for reads_item_i, input_reads_library_ref in enumerate(readsSet_ref_list):
            exec_k2_params = {'input_refs': input_reads_library_ref,
                              'read_type': read_type, 'db_type': params['db_type']}
            exec_k2_params['confidence'] = params['confidence'] if 'confidence' in params else exec_k2_params
            report += "RUNNING KRAKEN2 ON LIBRARY: " + str(input_reads_library_ref) + " " + str(
                readsSet_names_list[reads_item_i]) + "\n"
            report += "-----------------------------------------------------------------------------------\n\n"

            k2_single_library_ret_val = self.process_reads(ctx, exec_k2_params)[0]

            # add to report
            report += k2_single_library_ret_val['report_name'] + "\n\n"


        # create return output object
        output = {'report': report,
                  }
        #END run_kraken2

        # At some point might do deeper type checking...
        if not isinstance(output, dict):
            raise ValueError('Method run_kraken2 return value ' +
                             'output is not type dict as required.')
        # return the results
        return [output]

    def process_reads(self, ctx, input_params):
        #BEGIN process_reads
        console = []
        self.log(console, 'Running Kraken2 with parameters: ')
        self.log(console, "\n" + pformat(input_params))
        report = ''
        retVal = dict()
        retVal['output_filtered_ref'] = None
        retVal['output_unpaired_fwd_ref'] = None
        retVal['output_unpaired_rev_ref'] = None

        token = ctx['token']
        wsClient = workspaceService(self.workspaceURL, token=token)
        headers = {'Authorization': 'OAuth ' + token}
        env = os.environ.copy()
        env['KB_AUTH_TOKEN'] = token

        # object info
        [OBJID_I, NAME_I, TYPE_I, SAVE_DATE_I, VERSION_I, SAVED_BY_I, WSID_I, WORKSPACE_I, CHSUM_I, SIZE_I,
         META_I] = range(11)  # object_info tuple

        # Set_types = ["KBaseSets.ReadsSet", "KBaseRNASeq.RNASeqSampleSet"]
        PE_types = ["KBaseFile.PairedEndLibrary", "KBaseAssembly.PairedEndLibrary"]
        SE_types = ["KBaseFile.SingleEndLibrary", "KBaseAssembly.SingleEndLibrary"]
        acceptable_types = PE_types + SE_types

        # param checks
        required_params = ['input_reads_ref',
                           'output_reads_name',
                           'read_type'
                           ]
        for required_param in required_params:
            if required_param not in input_params or input_params[required_param] == None:
                raise ValueError("Must define required param: '" + required_param + "'")

        # Determine whether read library is of correct type
        #
        try:
            input_reads_obj_info = \
            wsClient.get_object_info_new({'objects': [{'ref': input_params['input_reads_ref']}]})[0]
            input_reads_obj_type = input_reads_obj_info[TYPE_I]
            # input_reads_obj_version = input_reads_obj_info[VERSION_I]  # this is object version, not type version

        except Exception as e:
            raise ValueError('Unable to get read library object from workspace: (' + str(
                input_params['input_reads_ref']) + ')' + str(e))

        input_reads_obj_type = re.sub('-[0-9]+\.[0-9]+$', "", input_reads_obj_type)  # remove trailing version
        acceptable_types = PE_types + SE_types
        if input_reads_obj_type not in acceptable_types:
            raise ValueError(
                "Input reads of type: '" + input_reads_obj_type + "'.  Must be one of " + ", ".join(
                    acceptable_types))

        # Confirm user is paying attention (matters because Trimmomatic params are very different for PairedEndLibary and SingleEndLibrary
        #
        if input_params['read_type'] == 'PE' and not input_reads_obj_type in PE_types:
            raise ValueError("read_type set to 'Paired End' but object is SingleEndLibrary")
        if input_params['read_type'] == 'SE' and not input_reads_obj_type in SE_types:
            raise ValueError("read_type set to 'Single End' but object is PairedEndLibrary")

        # Instatiate ReadsUtils
        #
        try:
            readsUtils_Client = ReadsUtils(url=self.callback_url, token=ctx['token'])  # SDK local

            readsLibrary = readsUtils_Client.download_reads(
                {'read_libraries': [input_params['input_reads_ref']],
                 'interleaved': 'false'
                 })
        except Exception as e:
            raise ValueError('Unable to get read library object from workspace: (' + str(
                input_params['input_reads_ref']) + ")\n" + str(e))
        input_string = []
        if input_params['read_type'] == 'PE':
            # Download reads Libs to FASTQ files
            input_fwd_file_path = readsLibrary['files'][input_params['input_reads_ref']]['files']['fwd']
            input_rev_file_path = readsLibrary['files'][input_params['input_reads_ref']]['files']['rev']
            input_string.append('--paired')
            input_string.append(input_fwd_file_path)
            input_string.append(input_rev_file_path)
        else:
            self.log(console, "Downloading Single End reads file...")
            # Download reads Libs to FASTQ files
            input_fwd_file_path = readsLibrary['files'][input_params['input_reads_ref']]['files']['fwd']
            input_string.append(input_fwd_file_path)

        output_dir = os.path.join(self.shared_folder, 'kraken2_output')
        report_file_name = 'report.txt'
        report_file = os.path.join(output_dir, report_file_name)
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        cmd = ['kraken2', '-db', '/data/kraken2/' + input_params['db_type'],
               '--output', output_dir, '--report', report_file,
               '--threads', '1']
        cmd.extend(['--confidence', str(input_params['confidence'])]) if 'confidence' in input_params else cmd

        cmd.extend(input_string)
        cmdProcess = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)
        outputlines = []
        while True:
            line = cmdProcess.stdout.readline()
            outputlines.append(line)
            if not line: break
            self.log(console, line.replace('\n', ''))

        cmdProcess.stdout.close()
        cmdProcess.wait()
        self.log(console, 'return code: ' + str(cmdProcess.returncode) + '\n')
        if cmdProcess.returncode != 0:
            raise ValueError('Error running kb_trimmomatic, return code: ' +
                             str(cmdProcess.returncode) + '\n')
        columns = [
            'Percentage of fragments covered by the clade rooted at this taxon',
            'Number of fragments covered by the clade rooted at this taxon',
            'Number of fragments assigned directly to this taxon', 'rank code',
            'taxid', 'name']
        report_df = pd.read_csv(report_file, sep='\t',
                                header=None, names=columns)
        code_dict = {'U': 'Unclassified', 'R': 'Root', 'D': 'Domain',
                     'K': 'Kingdom', 'P': 'Phylum', 'C': 'Class', 'O': 'Order',
                     'F': 'Family', 'G': 'Genus', 'S': 'Species'}
        report_df['rank code'] = report_df['rank code'].apply(
            lambda x: code_dict[x[0]] + x[1] if len(x) > 1 else code_dict[x])

        report_html_file = os.path.join(output_dir, 'report.html')
        self._generate_report_table(report_df, report_html_file, output_dir)
        # report_df.to_html(report_html_file, classes='Kraken2_report', index=False)
        html_zipped = self.package_folder(output_dir, 'report.html',
                                          'report')
        # Step 5 - Build a Report and return
        objects_created = []
        output_files = os.listdir(output_dir)
        output_files_list = []
        for output in output_files:
            if not os.path.isdir(output):
                output_files_list.append(
                    {'path': os.path.join(output_dir, output), 'name': output})
        message = f"Kraken2 run finished on {input_string} against {input_params['db_type']}."
        report_params = {'message': message,
                         'workspace_name': input_params.get('workspace_name'),
                         'objects_created': objects_created,
                         'file_links': output_files_list,
                         'html_links': [html_zipped],
                         'direct_html_link_index': 0,
                         'html_window_height': 460}

        # STEP 6: construct the output to send back
        kbase_report_client = KBaseReport(self.callback_url)
        report_output = kbase_report_client.create_extended_report(
            report_params)
        report_output['report_params'] = report_params
        logging.info(report_output)
        # Return references which will allow inline display of
        # the report in the Narrative
        output = {'report_name': report_output['name'],
                  'report_ref': report_output['ref'],
                  'report_params': report_output['report_params']
                  }
        #END process_reads

        # At some point might do deeper type checking...
        if not isinstance(output, dict):
            raise ValueError('Method execTrimmomaticSingleLibrary return value ' +
                             'output is not type dict as required.')
        # return the results
        return [output]

    def status(self, ctx):
        #BEGIN_STATUS
        returnVal = {'state': "OK",
                     'message': "",
                     'version': self.VERSION,
                     'git_url': self.GIT_URL,
                     'git_commit_hash': self.GIT_COMMIT_HASH}
        #END_STATUS
        return [returnVal]
